# IPC流用可能部 IPC Diversion Section

## 概要 Overview

* ServerとClientの通信処理(IPC)部分を汎用的に実装したものです。A general implementation of the Server and Client inter-processing communication (IPC) part.
* 大きく以下で構成されています。It consists largely of the following:
  * IPCライブラリ実装ソースIPC library implementation source: src, include
  * IPC単体テスト用プログラムIPC unit test program: ipc_unit_test

# ビルド方法Build Method

* 以下の手順でビルド可能です。You can build it by following these steps:
  ```bash
  $ mkdir build
  $ cd build
  $ cmake ..
  $ make
  ```
  * 上記のコマンドは以下のスクリプトでも実行可能です。 The above command can be executed with the following script. 
    ```bash
    $ ./buildtest.sh
    ```

後述するインストールでは、ホストPC(/usr/local/)にインストールされる。インストール先を変更するためには、cmakeに渡すオプションを変更する。
In the installation described later, it will be installed on the host PC (/ usr / local /). To change the installation destination, change the options passed to cmake.

```
例 Example 
$ cmake -DCMAKE_INSTALL_PREFIX=./install ..
```

# インストール方法 Install method

  ```bash
  $ cd build
  $ sudo make install
  ```

成功すると、下記のログが出力される。If successful, the following log will be output. 

```
[100%] Built target ipc
Install the project...
-- Install configuration: ""
-- Installing: /usr/local/lib/pkgconfig/ipc.pc
-- Installing: /usr/local/lib/libipc.so.1.0.0
-- Installing: /usr/local/lib/libipc.so.1
-- Installing: /usr/local/lib/libipc.so
-- Installing: /usr/local/include/ipc.h
-- Installing: /usr/local/include/ipc_protocol.h
```

# ビルド生成物 Build Product 

* ビルドにより、最終的には以下が生成されます。  By build, Eventually the following will be generated:
  * \<installdir\>/include/ 以下 the following
    外部公開向けヘッダファイル  header file for public disclosure
    ```bash
    ipc.h
    ipc_protocol.h
    ```
  * \<installdir\>/lib/ 以下  the following
    共有ライブラリファイル  Shared library file 
    ```bash
    libipc.so   (シンボリックリンク Symbolic link ) 
    libipc.so.1 (シンボリックリンク Symbolic link )
    libipc.so.1.0.0
    ```
  * build/ipc_unit_test/ 以下  the following
    テストプログラム実行ファイル  Test program executable file
    ```bash
    ipc_unit_test_client
    ipc_unit_test_server
    ```
<br>

# 使用方法 how to use

* 本ライブラリにはServer用とClient用の機能が入っており、それぞれ使用方法の異なる部分があります。
* This library contains functions for Server and Client, Each has different uses.

## Server/Client共通 Common

* 使用者は以下のライブラリとリンクする必要があります。The user needs to link with the following libraries.
  * `libipc.so`
* 本ライブラリ使用者は以下をincludeします。This library user do the following include
  * #include <ipc.h>
    * 後述のipc_protocol.hはipc.h内からincludeされるため、記載不要です。ipc_protocol.h described within ipc.h (include <ipc.h>), so It isnot necessary to describe ipc_protocol.h.
* 使用するヘッダファイルは以下の通りです。The header files used are as follows.
  * ipc.h
    * 使用可能なAPI関数一覧が宣言されています。A list of available API functions is declared.
  * ipc_protocol.h
    * IPCの用途種別と、各用途に応じたデータ構造体が定義されています。IPC usage types and data structures for each usage are defined.
* 本ライブラリでは、Unix Domain Socketを用いてServerとClientが通信します。In this library, Server and Client communicate using Unix Domain Socket.
  * 用途種別ごとに異なる通信用ファイルを生成します。Generates different communication files for each usage type. 
  * デフォルトではServerの実行階層に通信用ファイルを生成します。By default, a communication file is generated in the execution hierarchy of Server.
  * 環境変数 "IPC_DOMAIN_PATH" を設定しておくことで、通信用ファイルの生成場所を変更することができます。You can change the location where the communication file is generated by setting the environment variable "IPC _ DOMAIN _ PATH".
  ```
  例 Example)
  $ export IPC_DOMAIN_PATH="/tmp"
    →/tmp以下にUnix Domain Socket通信用ファイルが生成されるようになる。Unix Domain Socket communication files will be generated under / tmp.
  ```

## For IC-Service向け

* 本ライブラリをIC-Service向けに使用する場合、以下の値・構造体を用います(ipc_protocol.h参照)。When using this library for IC-Service, use the following values and structures (see ipc_protocol.h). 
  * 用途種別 usageType：IPC_USAGE_TYPE_IC_SERVICE
  * 送信データ構造体 Transmission data structure：IPC_DATA_IC_SERVICE_S
  * 変化種別コールバック通知用enum Change type callback notification to enum：IPC_KIND_IC_SERVICE_E
  * Unix Domain Socket通信用ファイル名  Unix Domain Socket communication File name：IpcIcService
* IC-Serviceの場合、Cluster APIライブラリ(libcluster_api.so)がIPC Clientとなっています。For IC-Service, the Cluster API library (libcluster_api.so) is the IPC Client. 
  * 後述のClient用 APIは、libcluster_api.so内から呼び出されます。The API for Client described below is called from within libcluster_api.so.

## Server用 API API for Server

* libipc.soを用いるServerは以下のAPIを使用できます。Servers using libipc.so can use the following APIs:
  * ipcServerStart(IPC_USAGE_TYPE_E usageType);
    * 指定した用途種別usageType用のIPC Serverを起動します。Start the IPC Server for the specified usageType.
  * ipcSendMessage(IPC_USAGE_TYPE_E usageType, const void* pData, signed int size);
    * 指定した用途種別usageType用に、IPC Clientへのデータ送信を行います。Sends data to the IPC Client for the specified usageType. 
    * 送信データのアドレスとサイズを引数pData, sizeで指定します。Specify the address and size of the transmission data with the arguments pData and size. 
    * 送信データは、IPC Client側で用意しているData Poolに格納されます。The transmitted data is stored in the Data Pool prepared on the IPC Client side.
  * ipcServerStop(IPC_USAGE_TYPE_E usageType);
    * 指定した用途種別usageType用のIPC Serverを終了します。Terminates the IPC Server for the specified usageType.

## Client用 API Client API

* libipc.soを用いるClientは以下のAPIを使用できます。Client using libipc.so can use the following APIs:
  * ipcClientStart(IPC_USAGE_TYPE_E usageType);
    * 指定した用途種別usageType用のIPC Clientを起動します。Start the IPC Client for the specified usageType.
    * 同じusageType用のIPC Serverと接続します。Connect with an IPC Server for the same usageType.
  * ipcReadDataPool(IPC_USAGE_TYPE_E usageType, void* pData, signed int* pSize);
    * 指定したusageType用のData Poolの全データを読み込みます。Reads all data in the Data Pool for the specified usageType.
    * 読み込みデータ格納先のアドレスはpDataに、格納可能なサイズはpSizeに指定します。The address to store the read data is specified in pData, and the size that can be stored is specified in pSize.
    * Data Poolの内容はpDataに出力され、実際に読み込めたサイズはpSizeに出力されます。The contents of the Data Pool are written to pData, and the actual size read is written to pSize.
  * ipcRegisterCallback(IPC_USAGE_TYPE_E usageType, IPC_CHANGE_NOTIFY_CB changeNotifyCb);
    * IPC Serverからデータを受信した時、どのデータが何に変化したかの通知を受けるためのコールバック関数を、指定したusageType用に登録します。When data is received from the IPC Server, a callback function for receiving notification of what data has changed to what is registered for the specified usageType. 
  * ipcClientStop(IPC_USAGE_TYPE_E usageType);
    * 指定した用途種別usageType用のIPC Clientを終了します。Terminates the IPC Client for the specified usageType.

# 単体テスト実行方法 Unit test execution method

* 制限  Limitations
  * 2020/12/25現在、このテストプログラムは必ずIC-Service用としてServerとClientを接続します。Currently 2020/12/25, this test program always connects Server and Client for IC-Service.  
  * unix domain socket通信用ファイルは /tmp/ 以下に ipcIcService というファイル名で生成されます。 The unix domain socket communication file is generated under/tmp/with the file name ipcIcService.

* ipc_unit_test_server と ipc_unit_test_client 間でプロセス間通信を行いますので、それぞれを別々のターミナルで起動します。Since Interprocess communication takes place between ipc _ unit _ test _ server and ipc _ unit _ test _ client, so start each in a separate terminal.
  
  操作は手動ですが、以下、テストの一例です。 The operation is manual, but the following is an example of the test.

  1. **Server, Clientの順に起動します。**  Start Server and then start Client
      ```bash
      (Terminal 1)
      $ ./ipc_unit_test_server
      command (h=help, q=quit):
      ```
      ```bash
      (Terminal 2)
      $ ./ipc_unit_test_client
      command (h=help, q=quit):
      ```  
      この時点でServerとClientはIC-Service用として接続済みです。  At this point, the Server and Client are already connected for IC-Service.
      (ipcServerStart()とipcClientStart()が実行されています)  (ipcServerStart () and ipcClientStart () are running)

  2. **Server側の送信データを適当に編集して送信してみます。**  I will edit the data sent by the server and send it.
      ```bash
      (Terminal 1)
      command (h=help, q=quit):w ←★ w を入力 input w 
      write command (h=help q=goto main menu):2 1 ←★2 1を入力 input 2 1
      write command (h=help q=goto main menu):70 50 ←★70 50を入力 input 70 50
      write command (h=help q=goto main menu):l ←★l を入力 input 1
      ★送信データ一覧が表示されるが、以下、入力内容が反映されていること。Transmitted data list is displayed, but the input contents are reflected below. 
        2: brake(4) = 1 ←★write command 2 1 の結果 result of write command 2 1
        70: oTempUnitVal(4) = 50 ←write command 70 50 の結果 result of write command 70 50
      write command (h=help q=goto main menu):q ←★q を入力 input q
      command (h=help, q=quit):s ←★s を入力(ipcSendMessage()の実行) input s (Executing ipcSendMessage())
      ipcSendMessage return:0
      command (h=help, q=quit):
      ```
      Client側にコールバック関数の反応が出ているはず。There should be a callback function response on the Client side.
      ```bash
      (Terminal 2)
      command (h=help, q=quit):Enter changeNotifyCb ←★コールバック callback
      kind = 2, size = 4, data=1 ←★brakeの値が1に変わったことを通知 Notify that the brake value has changed to 1
      Leave changeNotifyCb
      ```
      ★oTempUnitValの変化についてはIC-Serviceとしては監視対象でないのでコールバック無し。There is no callback for changes in TempUnitVal because it is not monitored as an IC-Service.

  3. **Client側で受信できているか確認します。**  Check if it can be received on the Client side.
      ```bash
      (Terminal 2)
      command (h=help, q=quit):r ←★r を入力 input r
      ★送信データ一覧が表示されるが、以下、送信されたデータが入っていること。Transmitted data list is displayed, The following contain the transmitted data. 
        2: brake(4) = 1
       70: oTempUnitVal(4) = 50
      ```

  4. **Client, Serverの順に終了します。** Exit Client and then exit Server.
      ```bash
      (Terminal 2)
      command (h=help, q=quit):q
      bye...
      $
      ```
      ```bash
      (Terminal 1)
      command (h=help, q=quit):q
      bye...
      $
      ```

# IPC用途種別の追加・変更方法 How to add/change IPC usage type
 
* まずはIC-Service向けにのみ実装しましたが、別の用途向けのデータを容易に追加することが可能なように構成しています。 First, it was implemented only for IC-Service, but we configured it so that we can easily add data for other usage.
* 各用途種別向けの情報は、以下のファイルにて管理しています。Information for each usage type is managed in the following files.
  * include/ipc_protocol.h (外部公開ヘッダ Externally Published Header)
  * src/ipc_usage_info_table.c (IPC内部向けソース IPC Internal Sources)
* 新規用途の情報追加、もしくは既存用途への情報変更は上記2つのファイルに対してのみ行うだけで良いようにしています。It is only necessary to add information for new usage or change information for existing uses for the above two files.
  * ipc内の他の.cファイルや.hファイルに対しては変更不要です。 No changes are required for other .c or .h files in ipc.
  * ただし、その用途でIPCを用いるアプリやテストプログラムに対しては、ipc_protocol.hへの定義追加・変更に合わせた対応が別途必要になります。However, for apps and test programs that use IPC for that purpose, it is need to take additional measures according to the addition / change of the definition in ipc_protocol.h.
* 理想ではツール等でコードを自動生成できることが理想ですが、今回はそこまでの実装を考慮しておりません。Ideally, code can be generated automatically using tools, etc., but this time we don't consider implementating it.

## 用途種別の追加・変更に関するサンプルコード（差分） Sample code for adding / changing the usage type (Sample code difference)

まずは2つのファイルに対してどのように追加・変更する際のサンプルコードを示します。
First, the sample code for how to add / modify two files as follow.

### 例1：新規の用途種別を追加する場合 Example 1: When adding a new usage type

仮にNEW_SERVICEという用途種別を追加する場合の差分例を示します。The following shows an example of the difference when adding usage type NEW_SERVICE.
IPC内における、新規の用途種別追加による影響範囲となります。Influence range of the addition of a new usage types within the IPC.

```patch
diff --git a/include/ipc_protocol.h b/include/ipc_protocol.h
index c0ad861..2bc1115 100644
--- a/include/ipc_protocol.h
+++ b/include/ipc_protocol.h
@@ -6,6 +6,7 @@
 typedef enum {
     IPC_USAGE_TYPE_IC_SERVICE = 0,
     IPC_USAGE_TYPE_FOR_TEST,
+    IPC_USAGE_TYPE_NEW_SERVICE, // 用途種別追加 Addition of usage type
     IPC_USAGE_TYPE_MAX
 } IPC_USAGE_TYPE_E;

@@ -145,4 +146,17 @@ typedef struct {
     signed int test;
 } IPC_DATA_FOR_TEST_S;

+// for IPC_USAGE_TYPE_NEW_SERVICE
+typedef enum { // データ変化を監視・通知したい種別のみ用意 Only the types for which you want to monitor/notify data changes are available
+    IPC_KIND_NS_PARAM1 = 0,
+    IPC_KIND_NS_PARAM2
+} IPC_KIND_NEW_SERVICE_E;
+
+typedef struct { // この用途で送受信する全データ All data sent and received for this usage
+    int param1;
+    int param2;
+    int param3;
+    int param4;
+} IPC_DATA_NEW_SERVICE_S;
+
 #endif // IPC_PROTOCOL_H
diff --git a/src/ipc_usage_info_table.c b/src/ipc_usage_info_table.c
index 976cc73..51264c6 100644
--- a/src/ipc_usage_info_table.c
+++ b/src/ipc_usage_info_table.c
@@ -51,16 +51,24 @@ static IPC_CHECK_CHANGE_INFO_S g_ipcCheckChangeForTest[] = {
     DEFINE_OFFSET_SIZE(IPC_DATA_FOR_TEST_S, test, IPC_KIND_TEST_TEST)
 };

+//   for IPC_USAGE_TYPE_FOR_TEST
+static IPC_CHECK_CHANGE_INFO_S g_ipcCheckChangeNewService[] = { // データ変化を監視・通知したい種別のみ記載 Describe only the type  you want to monitor / notify of data changes
+    DEFINE_OFFSET_SIZE(IPC_DATA_NEW_SERVICE_S, param1, IPC_KIND_NS_PARAM1),
+    DEFINE_OFFSET_SIZE(IPC_DATA_NEW_SERVICE_S, param2, IPC_KIND_NS_PARAM2)
+}; // この例では、param3, param4のデータ変化については監視・通知しない。This example donot want to monitor/notify changed of param3, param4 data
+
 // == usage info table ==
 //   index of [] is IPC_USAGE_TYPE_E
 IPC_DOMAIN_INFO_S g_ipcDomainInfoList[] =
 {
     {sizeof(IPC_DATA_IC_SERVICE_S), "ipcIcService"},
-    {sizeof(IPC_DATA_FOR_TEST_S), "ipcForTest"}
+    {sizeof(IPC_DATA_FOR_TEST_S), "ipcForTest"},
+    {sizeof(IPC_DATA_NEW_SERVICE_S), "ipcNewService"} // 新規用途用の送受信サイズ情報追加 add information of new usage sending/receiving size   
 };

 IPC_CHECK_CHANGE_INFO_TABLE_S g_ipcCheckChangeInfoTbl[] = {
     DEFINE_CHANGE_INFO_TABLE(g_ipcCheckChangeIcService),
-    DEFINE_CHANGE_INFO_TABLE(g_ipcCheckChangeForTest)
+    DEFINE_CHANGE_INFO_TABLE(g_ipcCheckChangeForTest),
+    DEFINE_CHANGE_INFO_TABLE(g_ipcCheckChangeNewService) // 新規用途用 データ変化監視テーブルを登録 Register monitor table of new usage changed data
 };

```

### 例2：既存の用途種別のデータの一部を削除する場合 Example 2: When deleting part of the existing usage type data

既存の用途IC-Serviceの送受信データから、メンバ変数brakeを削除する場合の差分例を示します。An example of the difference when the member variable brake is deleted from the transmission / reception data of the existing usage IC-Service is shown below.
IPC内における、メンバ変数を削除した場合の影響範囲となります。。Influence range of the deleting member variable within the IPC.

```patch
diff --git a/include/ipc_protocol.h b/include/ipc_protocol.h
index c0ad861..7fed8bf 100644
--- a/include/ipc_protocol.h
+++ b/include/ipc_protocol.h
@@ -13,7 +13,6 @@ typedef enum {
 typedef enum {
     IPC_KIND_ICS_TURN_R = 0,
     IPC_KIND_ICS_TURN_L,
-    IPC_KIND_ICS_BRAKE,
     IPC_KIND_ICS_SEATBELT,
     IPC_KIND_ICS_HIGHBEAM,
     IPC_KIND_ICS_DOOR,
@@ -51,7 +50,6 @@ typedef struct {
     // Telltale
     signed int turnR;
     signed int turnL;
-    signed int brake;
     signed int seatbelt;
     signed int frontRightSeatbelt;
     signed int frontCenterSeatbelt;
diff --git a/src/ipc_usage_info_table.c b/src/ipc_usage_info_table.c
index 976cc73..40ac8df 100644
--- a/src/ipc_usage_info_table.c
+++ b/src/ipc_usage_info_table.c
@@ -12,7 +12,6 @@
 static IPC_CHECK_CHANGE_INFO_S g_ipcCheckChangeIcService[] = {
     DEFINE_OFFSET_SIZE(IPC_DATA_IC_SERVICE_S, turnR, IPC_KIND_ICS_TURN_R),
     DEFINE_OFFSET_SIZE(IPC_DATA_IC_SERVICE_S, turnL, IPC_KIND_ICS_TURN_L),
-    DEFINE_OFFSET_SIZE(IPC_DATA_IC_SERVICE_S, brake, IPC_KIND_ICS_BRAKE),
     DEFINE_OFFSET_SIZE(IPC_DATA_IC_SERVICE_S, seatbelt, IPC_KIND_ICS_SEATBELT),
     DEFINE_OFFSET_SIZE(IPC_DATA_IC_SERVICE_S, highbeam, IPC_KIND_ICS_HIGHBEAM),
     DEFINE_OFFSET_SIZE(IPC_DATA_IC_SERVICE_S, door, IPC_KIND_ICS_DOOR),
```

## 用途種別の新規追加に関する共通事項 Common matters regarding the addition of a new use type

* いくつか列挙体・構造体の新規追加、および既存の列挙体・構造体内への追記を伴いますが、いずれも名称については特に制約はありません。Some new enumerations / structures will be added, and some enumerations / structures will be added to existing enumerations / structures, but there are no particular restrictions on the names of any of them.

## include/ipc_protocol.h へ追記する情報 Information added to include/ipc_protocol.h
* 1つの用途種別に対し、以下の3つの情報を追記します。
Add the following three information for one usage type.
  * 用途種別名の追記 Addition of usage type name
  * 新規用途向けの変化通知種別用列挙体の定義 Definition of enumeration for change notification type for new usage
  * 新規用途向けの送受信データ構造体の定義 Definition of send/receive data structure for new usage
* 用途種別名の追記 Addition of usage type name
  * サンプルコードの以下の部分のことになります。Sample code of this part will be as follow:
    ```patch
     typedef enum {
         IPC_USAGE_TYPE_IC_SERVICE = 0,
         IPC_USAGE_TYPE_FOR_TEST,
    +    IPC_USAGE_TYPE_NEW_SERVICE, // 用途種別追加 Adding of usage type
         IPC_USAGE_TYPE_MAX
     } IPC_USAGE_TYPE_E;
    ```
  * enum IPC_USAGE_TYPE_E 内に用途種別となるメンバを追加します。Add a member for the usage type in enum IPC_USAGE_TYPE_E.
  * IPC_USAGE_TYPE_MAXの1つ手前に追加するようにしてください(既存の定義に影響を及ぼさないようにするため)。Make sure to add it just before IPC_USAGE_TYPE_MAX (to avoid affecting existing definitions)
  * ここで定義した値は、ipc.hで定義されているipcServerStart()などの引数usageTypeへの指定用に使用します。
The value defined here is used to specify the argument usageType such as ipcServerStart() defined in ipc.h.
* 新規用途向けの変化通知種別用列挙体の定義 Definition of enumeration for change notification type for new usage
  * サンプルコードの以下の部分のことになります。Sample code of this part will be as follow:
    ```patch
    +typedef enum { // データ変化を監視したい種別のみ用意 
Only the types for which you want to monitor data changes are available
    +    IPC_KIND_NS_PARAM1 = 0,
    +    IPC_KIND_NS_PARAM2
    +} IPC_KIND_NEW_SERVICE_E;
    ```
  * データ変化通知の種別用列挙体を追加します。後述の送受信データ構造体と関連があります。Adds an enumeration for the type of data change notification. Related to the send and receive data structures described below.
  * この値は、ipcRegisterCallback()で登録されたコールバック関数の第3引数kindへの指定に使用します。This value is used to specify the callback function registered by ipcRegisterCallback () in the third argument kind.
  * 列挙体名、メンバ名について、特に名称の制約はありません。There are no specific naming restrictions for enumeration and member names
* 新規用途向けのデータ構造体の定義 Definition of send/receive data structure for new usage
  * サンプルコードの以下の部分のことになります。Sample code of this part will be as follow:
    ```patch
    +typedef struct { // この用途で送受信する全データ all data send/receive by this usage
    +    int param1;
    +    int param2;
    +    int param3;
    +    int param4;
    +} IPC_DATA_NEW_SERVICE_S;
    ```
  * 新規用途で送受信するデータ構造体を追加します。 Add data structures to send/receive for the new use.
  * IPC ServerからIPC Clientへは、ここで定義した構造体のデータ全てを送信することになります。The IPC Server will send all the data in the structure defined here to the IPC Client.

## Regarding adding src/ipc_usage_info_table.c
* 1つの用途種別に対し、以下の3つの情報を追記します。Add the following 3 information for one usage type
  * データ変化通知用の種別対応テーブルの追加 Adding a type correspondence table for data change notification
  * 通信用ドメイン情報追記(通信サイズ、ドメインファイル名) Adding communication domain information (Communication size and domain file name)
  * 用途と変化種別対応テーブルとの関係追記 Adding the relationship between usage and change type correspondence table 
* データ変化通知用の種別対応テーブルの追加 Adding a type correspondence table for data change notification
  * サンプルコードの以下の部分のことになります。Sample code of this part will be as follow:
    ```
    +//   for IPC_USAGE_TYPE_FOR_TEST
    +static IPC_CHECK_CHANGE_INFO_S g_ipcCheckChangeNewService[] = { // データ変化を監視・通知したい種別のみ記載
    +    DEFINE_OFFSET_SIZE(IPC_DATA_NEW_SERVICE_S, param1, IPC_KIND_NS_PARAM1),
    +    DEFINE_OFFSET_SIZE(IPC_DATA_NEW_SERVICE_S, param2, IPC_KIND_NS_PARAM2)
    +}; // この例では、param3, param4のデータ変化については監視・通知しない。
    ```
  * 新規用途向けに、IPC_CHECK_CHANGE_INFO_Sの構造体配列を追加します。
  * ipc_protocol.hで定義した変化通知種別用列挙体の定義と、通信するデータ構造体メンバを対応付けるテーブルを記載します。
  * このテーブルは、IPC ClientがIPC Serverからデータを受信する時に、前回受信時と変化しているデータ種別をコールバック通知する際に使用します。
  * 構造体配列内には、以下のようなマクロを複数個記載して対応を定義します。
    ```c
    DEFINE_OFFSET_SIZE(<データ構造体名>, <構造体メンバ名>, 変化通知列挙体メンバ名),
    ```
  * 上記サンプルコード、g_ipcCheckChangeNewService[]の場合は以下のようになります。
    * param1が前回受信時と値が異なる場合、変化種別 IPC_KIND_NS_PARAM1 としてIPC Clientへコールバック通知する。
    * param2が前回受信時と値が異なる場合、変化種別 IPC_KIND_NS_PARAM2 としてIPC Clientへコールバック通知する。
    * 記載していないparam3, param4については、前回受信時と値が異なっていてもコールバック通知はしない。

* 通信用ドメイン情報追記(通信サイズ、ドメインファイル名)
  * サンプルコードの以下の部分のことになります。
    ```patch
     IPC_DOMAIN_INFO_S g_ipcDomainInfoList[] =
     {
         {sizeof(IPC_DATA_IC_SERVICE_S), "ipcIcService"},
    -    {sizeof(IPC_DATA_FOR_TEST_S), "ipcForTest"}
    +    {sizeof(IPC_DATA_FOR_TEST_S), "ipcForTest"},
    +    {sizeof(IPC_DATA_NEW_SERVICE_S), "ipcNewService"} // 新規用途用の送受信サイズ情報追加
     };
    ```
  * 構造体配列 g_ipcDomainInfoList[] に、新規用途向けのドメイン情報を追記します。
  * この追記により、新規追加した用途種別で用いる送受信データサイズと、Unix Domain Socket通信で用いるドメインファイル名が決まります。
  * ipc_protocol.hのenum IPC_USAGE_TYPE_Eの定義順と一致させる必要があるので、必ず末尾に追加してください。
  * 以下のように、通信するデータ構造体のサイズと、ドメインファイル名の情報を、g_ipcDomainInfoList[] の末尾に追記します。
    ```c
    {sizeof(<通信するデータ構造体名>), "ドメインファイル名"},
    ```
* 用途と変化種別対応テーブルとの関係追記
  * サンプルコードの以下の部分のことになります。
    ```patch
     IPC_CHECK_CHANGE_INFO_TABLE_S g_ipcCheckChangeInfoTbl[] = {
         DEFINE_CHANGE_INFO_TABLE(g_ipcCheckChangeIcService),
    -    DEFINE_CHANGE_INFO_TABLE(g_ipcCheckChangeForTest)
    +    DEFINE_CHANGE_INFO_TABLE(g_ipcCheckChangeForTest),
    +    DEFINE_CHANGE_INFO_TABLE(g_ipcCheckChangeNewService) // 新規用途用 データ変化監視テーブルを登録
     };
    ```
  * 構造体配列 g_ipcCheckChangeInfoTbl[] に、新規用途向けの変化通知種別対応テーブルに関する情報を追記します。
  * ipc_protocol.hのenum IPC_USAGE_TYPE_Eの定義順と一致させる必要があるので、必ず末尾に追加してください。
  * 前述の「変化通知種別対応テーブル構造体」を、以下のようなマクロに記載し、g_ipcCheckChangeInfoTbl[]の末尾に追記します。
    ```c
    DEFINE_CHANGE_INFO_TABLE(<変化通知種別対応テーブル構造体名>),
    ```

## 既存用途向けの送信データを一部変更する場合
* ipc_protocol.h内の既存の送信データ構造体内のメンバ変数の削除、もしくは名称変更する場合
  * ipc部分、およびipcをその用途で用いるアプリをそれぞれビルドしてみて、コンパイルエラーとなった部分を修正します。

* ipc_protocol.h内の既存の送信データ構想体へメンバ変数を追加する場合
  * [IPC用途種別の追加・変更方法](#IPC用途種別の追加・変更方法) を参考に、include/ipc_protocol.hとsrc/ipc_usage_info_table.cへの追記を行います。

## 補足
* src/ipc_usage_info_table.cにて、DEFINE_OFFSET_SIZE()マクロにて情報を記載しているが、これはoffsetof()とsizeof()を使うことで、メンバ変数に関する構造体先頭からオフセットとサイズを取得しています。
  * 用途種別の追加を容易に行えるようにするため、IPC処理内部ではデータ構造体内の変数名を直接指定しないような実装を行っています。
  * 各用途に対して、データ構造体のオフセットテーブルを用意することで、送信されたデータの何バイト目に何の変数があるかがわかるようになります。
    * この仕組みにより、IPC処理内部でメンバ変数名を直接指定しなくとも、データ変化の確認が可能となります。
  * [IPC用途種別の追加・変更方法](#IPC用途種別の追加・変更方法) に従って用途種別を追加することで、IPC内部処理は新たな用途に対する処理ができるようになります。
